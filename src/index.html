<!DOCTYPE html><html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Baxter Swain | Home</title>
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Orbitron:wght@500&display=swap" />
  <style>
    :root {
      --space: 1rem;
      --bg: #09090b;
      --fg: #e3e3e3;
      --surface-1: #101012;
      --surface-2: #27272a;
      --surface-3: #52525b;
      --ease-out: cubic-bezier(0.5, 1, 0.89, 1);
      --ease-in-out: cubic-bezier(0.45, 0, 0.55, 1);
    }
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    body {
      font-family: 'Orbitron', sans-serif;
      background: var(--bg);
      color: var(--fg);
      min-height: 100vh;
      display: grid;
      place-items: center;
      padding: var(--space);
    }
    main {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: var(--space);
      max-width: 1000px;
      width: 100%;
    }
    .card {
      position: relative;
      overflow: hidden;
      display: grid;
      place-items: center;
      aspect-ratio: 4 / 5;
      border: 1px solid var(--surface-2);
      transition: border-color 200ms var(--ease-out);
      background: var(--surface-1);
      isolation: isolate;
      text-align: center;
      padding: 1rem;
      border-radius: 8px;
    }
    .card::before,
    .card::after {
      content: '';
      position: absolute;
      inset: 0;
      pointer-events: none;
      transition: opacity 600ms var(--ease-out);
    }
    .card::before {
      background: radial-gradient(circle at bottom left, transparent 55%, var(--surface-1));
      opacity: 1;
    }
    .card::after {
      margin: auto;
      aspect-ratio: 1;
      background: radial-gradient(circle, var(--bg), transparent 65%);
      opacity: 0;
    }
    .card:hover::before {
      opacity: 0;
    }
    .card:hover::after {
      opacity: 1;
    }
    .card svg {
      width: 50px;
      height: 50px;
      color: var(--surface-3);
      margin-bottom: 1rem;
      transition: transform 300ms var(--ease-in-out), color 300ms;
    }
    .card:hover svg {
      transform: scale(1.2);
      color: var(--fg);
    }
    .card button {
      background: none;
      border: 2px solid var(--fg);
      color: var(--fg);
      padding: 0.5rem 1rem;
      font-size: 1rem;
      border-radius: 999px;
      cursor: pointer;
      transition: background 0.3s, color 0.3s;
    }
    .card button:hover {
      background: var(--fg);
      color: var(--bg);
    }
    pixel-canvas {
      position: absolute;
      inset: 0;
      z-index: 0;
    }
    .card > *:not(pixel-canvas) {
      z-index: 1;
    }
  </style>
</head>
<body>
  <main>
    <div class="card" style="--active-color: #00ffe7">
      <pixel-canvas data-gap="10" data-speed="25" data-colors="#00ffe7, #00ccff, #0077ff"></pixel-canvas>
      <svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" viewBox="0 0 256 256">
        <path d="M216,42H40A14,14,0,0,0,26,56V200a14,14,0,0,0,14,14H216a14,14,0,0,0,14-14V56A14,14,0,0,0,216,42ZM40,54H216a2,2,0,0,1,2,2V98H38V56A2,2,0,0,1,40,54ZM38,200V110H98v92H40A2,2,0,0,1,38,200Zm178,2H110V110H218v90A2,2,0,0,1,216,202Z"/>
      </svg>
      <button onclick="location.href='projects.html'">Projects</button>
    </div>
    <div class="card" style="--active-color: #fef08a">
      <pixel-canvas data-gap="5" data-speed="20" data-colors="#fef08a, #fde047, #eab308"></pixel-canvas>
      <svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" viewBox="0 0 256 256">
        <path d="M180,146H158V110h22a34,34,0,1,0-34-34V98H110V76a34,34,0,1,0-34,34H98v36H76a34,34,0,1,0,34,34V158h36v22a34,34,0,1,0,34-34ZM158,76a22,22,0,1,1,22,22H158ZM54,76a22,22,0,0,1,44,0V98H76A22,22,0,0,1,54,76ZM98,180a22,22,0,1,1-22-22H98Zm12-70h36v36H110Zm70,92a22,22,0,0,1-22-22V158h22a22,22,0,0,1,0,44Z"/>
      </svg>
      <button onclick="location.href='about.html'">About</button>
    </div>
    <div class="card" style="--active-color: #e0f2fe">
      <pixel-canvas data-gap="6" data-speed="30" data-colors="#e0f2fe, #7dd3fc, #0ea5e9"></pixel-canvas>
      <svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" viewBox="0 0 256 256">
        <path d="M67.84,92.61,25.37,128l42.47,35.39a6,6,0,1,1-7.68,9.22l-48-40a6,6,0,0,1,0-9.22l48-40a6,6,0,0,1,7.68,9.22Zm176,30.78-48-40a6,6,0,1,0-7.68,9.22L230.63,128l-42.47,35.39a6,6,0,1,0,7.68,9.22l48-40a6,6,0,0,0,0-9.22Zm-81.79-89A6,6,0,0,0,154.36,38l-64,176A6,6,0,0,0,94,221.64a6.15,6.15,0,0,0,2,.36,6,6,0,0,0,5.64-3.95l64-176A6,6,0,0,0,162.05,34.36Z"/>
      </svg>
      <button onclick="location.href='contact.html'">Contact</button>
    </div>
  </main>
  <script>
    // JavaScript logic for <pixel-canvas>
    class PixelCanvas extends HTMLElement {
      static register(tag = "pixel-canvas") {
        if ("customElements" in window) customElements.define(tag, this);
      }
      static css = `:host{display:grid;inline-size:100%;block-size:100%;overflow:hidden;}`;
      get colors() {
        return this.dataset.colors?.split(",") || ["#f8fafc", "#f1f5f9", "#cbd5e1"];
      }
      get gap() {
        const value = this.dataset.gap || 5;
        return Math.max(4, Math.min(parseInt(value), 50));
      }
      get speed() {
        const value = this.dataset.speed || 35;
        return Math.max(0, Math.min(parseInt(value), 100)) * 0.001;
      }
      get noFocus() {
        return this.hasAttribute("data-no-focus");
      }
      connectedCallback() {
        const canvas = document.createElement("canvas");
        const sheet = new CSSStyleSheet();
        this._parent = this.parentNode;
        this.shadowroot = this.attachShadow({ mode: "open" });
        sheet.replaceSync(PixelCanvas.css);
        this.shadowroot.adoptedStyleSheets = [sheet];
        this.shadowroot.append(canvas);
        this.canvas = canvas;
        this.ctx = canvas.getContext("2d");
        this.timeInterval = 1000 / 60;
        this.timePrevious = performance.now();
        this.reducedMotion = window.matchMedia("(prefers-reduced-motion: reduce)").matches;
        this.init();
        this.resizeObserver = new ResizeObserver(() => this.init());
        this.resizeObserver.observe(this);
        this._parent.addEventListener("mouseenter", this);
        this._parent.addEventListener("mouseleave", this);
        if (!this.noFocus) {
          this._parent.addEventListener("focusin", this);
          this._parent.addEventListener("focusout", this);
        }
      }
      disconnectedCallback() {
        this.resizeObserver.disconnect();
        this._parent.removeEventListener("mouseenter", this);
        this._parent.removeEventListener("mouseleave", this);
        if (!this.noFocus) {
          this._parent.removeEventListener("focusin", this);
          this._parent.removeEventListener("focusout", this);
        }
        delete this._parent;
      }
      handleEvent(e) {
        this[`on${e.type}`](e);
      }
      onmouseenter() { this.handleAnimation("appear"); }
      onmouseleave() { this.handleAnimation("disappear"); }
      onfocusin(e) { if (!e.currentTarget.contains(e.relatedTarget)) this.handleAnimation("appear"); }
      onfocusout(e) { if (!e.currentTarget.contains(e.relatedTarget)) this.handleAnimation("disappear"); }
      handleAnimation(name) {
        cancelAnimationFrame(this.animation);
        this.animation = this.animate(name);
      }
      init() {
        const rect = this.getBoundingClientRect();
        const w = Math.floor(rect.width), h = Math.floor(rect.height);
        this.pixels = [], this.canvas.width = w, this.canvas.height = h;
        this.canvas.style.width = `${w}px`;
        this.canvas.style.height = `${h}px`;
        for (let x = 0; x < w; x += this.gap)
          for (let y = 0; y < h; y += this.gap)
            this.pixels.push(new Pixel(this.canvas, this.ctx, x, y, this.colors[Math.floor(Math.random() * this.colors.length)], this.speed, this.reducedMotion ? 0 : Math.sqrt(Math.pow(x - w / 2, 2) + Math.pow(y - h / 2, 2))));
      }
      animate(fn) {
        this.animation = requestAnimationFrame(() => this.animate(fn));
        const now = performance.now(), passed = now - this.timePrevious;
        if (passed < this.timeInterval) return;
        this.timePrevious = now - (passed % this.timeInterval);
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        for (let p of this.pixels) p[fn]();
        if (this.pixels.every(p => p.isIdle)) cancelAnimationFrame(this.animation);
      }
    }
    class Pixel {
      constructor(c, ctx, x, y, color, speed, delay) {
        this.ctx = ctx, this.x = x, this.y = y, this.color = color, this.speed = Math.random() * 0.9 * speed, this.size = 0, this.sizeStep = Math.random() * 0.4;
        this.maxSize = Math.random() * (2 - 0.5) + 0.5, this.delay = delay, this.counter = 0, this.counterStep = Math.random() * 4 + (c.width + c.height) * 0.01;
        this.isIdle = false, this.isReverse = false, this.isShimmer = false;
      }
      draw() {
        const off = 1 - this.size / 2;
        this.ctx.fillStyle = this.color;
        this.ctx.fillRect(this.x + off, this.y + off, this.size, this.size);
      }
      appear() {
        if (this.counter <= this.delay) return void (this.counter += this.counterStep);
        if (this.size >= this.maxSize) this.isShimmer = true;
        this.isShimmer ? this.shimmer() : (this.size += this.sizeStep);
        this.draw();
      }
      disappear() {
        if ((this.size -= 0.1) <= 0) return void (this.isIdle = true);
        this.draw();
      }
      shimmer() {
        if (this.size >= this.maxSize) this.isReverse = true;
        if (this.size <= 0.5) this.isReverse = false;
        this.size += this.isReverse ? -this.speed : this.speed;
      }
    }
    PixelCanvas.register();
  </script>
</body>
</html>
